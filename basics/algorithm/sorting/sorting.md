# 排序算法

## 插入排序 (insertion sorting)

时间复杂度：O(n^2)

包含元素array[0..j-1]的子数组构成了当前排序好的左手中的牌，剩余的子数组array[j..n-1]对应于仍在桌子上的牌堆。事实上，元素array[0..j-1]就是原来在位置0到j-1的元素，但现在已经按序排列。我们把array[0..j-1]的这些性质形式地表示为一个**循环不变式**

插入排序的算法设计技术使用了**增量**的方法。

> example: insertionSorting.cpp

在插入排序的插入步骤中，需要O(n)的时间才能把选取的数据插入到合适的位置，因为经典的插入排序是遍历整个已排序的数组的。然而，可以使用二分查找(binary searching)的思想把这一时间缩短至O(ln(n))。

> example: binaryInsertionSorting.cpp

↑ 这是我自己想出来的算法。其中binarySearch函数就是用来代替原来遍历的算法的。然而，在本题中二分查找可能是找不到原值的(是插值)，这就导致边界条件可能会很复杂...或者只有我觉得很复杂...所以我又去学习了很多其他人的算法：


emmmm其实他的算法比我高明的地方就在于他在递归的最开始使用了一个检测机制，检查mid索引和right索引之间的关系。这种trick还是需要多积累!


## 归并排序 (merge sorting)

> example: mergeSorting.cpp   (关键是有bug??????!)


时间复杂度：$O(n\log_2{n})$

空间复杂度：O(n)


原理：
1. 分解待排序的n个元素的序列成各具n/2个元素的两个子序列
2. 使用归并排序递归地排序两个子序列，当待排序的序列长度为1时，递归“开始回升”
3. 合并两个已经排序的子序列以产生已经排序的答案

归并排序算法的关键操作是“合并”步骤中两个已经排序的序列的合并。我们通过调用一个辅助过程MERGE(A, p, q, r)来完成合并。该过程假设子数组A[left...mid]和A[mid+1...right]都已经排好序，它将合并这两个子数组形成单一的已经排好序的子数组并代替当前的子数组A[left...right]

过程MERGE需要O(n)的时间。因为当两个子数组都已经排好序，考虑扑克牌的例子，我们只需要一次从两堆牌中选取较小的那一张牌并放入新的一堆牌中用于输出，直到某一堆牌被取完。这样总的时间需要(n)

在例子mergeSorting.c中实现了上面的思想，但有一个额外的变化，以避免在每个基本步骤必须检查是否有堆为空。在每个堆的底部放置一张哨兵牌，它包含一个特殊的值，用于简化代码。这里，我们使用0x3f3f3f3f(infinity)作为哨兵值，结果每当显露一张值为infinity的牌，它不可能为较小的牌，除非两个堆都已经显露出其哨兵牌，那样算法就可以停止。

**以上思想被修改。不再使用多余的一项作为哨兵值，这样容易出错。取而代之的是从left到mid和从mid+1到right同步进行循环，这样当某一个子数组到底的时候就会停止循环。再用两个while循环检查是哪一个子数组完成了循环，再将剩余的数据填入temp，最后再把temp中的数据写入array。这样总的时间复杂度仍然是O(nln(n))。考虑到虽然这种算法需要临时申请一个数组来暂时存放排好序的数据，但是这个临时空间是可以重复利用的，因此归并排序的空间复杂度为O(n)，最多需要存放n个数据。**

归并排序算法分析：
1. 归并排序是一个稳定的排序算法，在进行子数组合并的时候，我们可以设置当元素大小相等时，先将前半部分的数据放入临时数组，这样就可以保证相等元素在排序后依然保持原来的顺序(?)。
2. 不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递归公式。如果我们堆n个元素进行归并排序所需要的时间是T(n)，那分解成两个子数组排序的时间都是T(n/2)，而合并两个子数组的时间复杂度为O(n)。所以，归并排序的时间复杂度计算公式是：
    $$ T(1) = CT(n) = 2*T(\frac{n}{2})+n, n>1 $$
    n = 1时，只需要常量级的执行时间，所以表示为C
    $$ T(n) = 2T(\frac{n}{2})+n=2[2T(\frac{n}{4}+\frac{n}{2}]+n = 4T(\frac{n}{4})+2n \\ = 4[2T(\frac{n}{8})+\frac{n}{4}]+2n = 8T(\frac{n}{8})+3n \\...... \\ = 2^kT(\frac{n}{2^k}) + kn $$
    当$\frac{n}{2^k}=1$时，$k=\log_2{n}$，代入上式得：
    $$ T(n) = nC + n\log_2{n} $$
    所以归并排序的时间复杂度为$O(n\log_2{n})$



## 堆排序 (heap)

时间复杂度：O(nln(n))

时间复杂度与归并排序一样，但不同于插入排序。而与插入排序相同，但不同于归并排序的是，堆排序同样拥有空间原址性：任何时候都只需要常数个额外的元素空间存储临时数据。

堆排序引入了另一种算法设计技巧：使用一种我们称为“堆”的数据结构来进行信息管理。



## 快速排序 (quick sort)

与归并排序一样，快速排序也使用了分治思想。对一个典型的子数组 A[p..r] 进行快速排序的三步分治过程：
1. 分解：数组 A[p..r] 被划分为两个（可能为空）子数组 A[p..q-1] 和 A[q+1..r]，使得 A[p..q] 中的每一个元素都小于等于 A[q]，而 A[q] 也小于等于 A[q+1..r] 中的每个元素。其中，计算下标 q 也是划分过程的一部分
2. 解决：通过递归调用快速排序，对子数组 A[p..q-1] 和 A[q+1..r] 进行排序
3. 合并：因为子数组都是原址排序的，所以不需要合并操作

    QUICKSORT(A, p, r)
        if p < r
            q = PARTITION(A, p, r);
            QUICKSORT(A, p, q-1);
            QUICKSORT(A, q+1, r);

    // 算法的关键部分是PARTITION过程，它实现了对数组的原址重排
    PARTITION(A, p, r)
        x = A[r];
        i = p - 1;
        for j = p to r-1
            if A[j] <= x
                i = i + 1;                  这个 i，妙啊！！！
                exchange A[i] with A[j];
        exchange A[i+1] with A[r];
        return i+1；

快速排序的性能依赖于划分是否平衡，而平衡与否又依赖于用于划分的元素。其性能处于归并排序和插入排序之间。

1. 最坏情况划分

2. 最好情况划分

3. 平衡的划分

## 比较排序

到目前为止，这几种排序方法都能在 O(nlgn) 时间内排序 n 个数。这些算法都有一个有趣的性质：在排序的最终结果中，各元素的次序依赖于它们之间的比较。我们把这类排序称为比较排序。

接下来证明，对包含 n 个元素的输入序列来说，任何比较排序在最坏情况下都要经过 O(nlgn) 次比较。因此，归并排序和堆排序是渐进最优的，并且任何已知的比较排序最多就是在常数因子上优于它们

### 排序算法的下界

决策树模型


## 线性时间排序

### 计数排序

计数排序的基本思想是，堆每一个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放到它在输出数组的位置上了。

在计数排序算法的代码中，假设输入是一个数组 A[0..n]， A.length = n。我们还需要两个数组：B[0..n]存放排序的输出，C[0..k]提供临时存储空间。

    COUNTING-SORT(A, B, k)
        let C[0..k] be a new array;
        for i = 0 to k
            C[i] = 0;
        for j = 0 to A.length-1
            C[A[j]] = C[A[j]]+1;   //如何确定 C 的大小？？？？
        // C[i] now contains the number of elements equal to i
        for i = 0 to k-1
            C[i] = C[i] + C[i-1];\
        // C[i] now contain the number of elements less than or equal to i
        for j = A.length-1 downto 0
            B[C[A[j]]] = A[j];
            C[A[j]] = C[A[j]] - 1;
        // 因为所有的元素可能并不都是互异的，所以要将C[A[j]]的值-1

计数排序的总的时间代价是 O(k+n)。在实际工作中，当 k = O(n) 时，我们一般会采用计数排序，这时的运行时间为 O(n)。


计数排序的一个重要性质就是它是**稳定的**：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。


### 基数排序 (??????)

### 桶排序 (???)

桶排序将 [0, 1) 区间划分为 n 个相同大小的子区间，或称为 **桶**，然后，将 n 个输入数分别放到各个桶中。因为输入数据是均匀、独立地分布的，所以一般不会出现很多散落在同一个桶中的情况。为了得到输出结果，我们先对每个桶中的数据进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出了即可。

在桶排序的代码中，我们假设输入是一个包含 n 个元素的数组 A，且每个元素 A[i] 满足 0 <= A[i] < 1。此外，算法还需要一个临时数组 B[0..n-1] 来存放链表（即桶），并假设存在一种用于维护这些链表的机制。

    BUCKET-SORT(A)
        n = A.length;
        let B[0..n-1] be new array;
        for i = 0 to n-1
            make B[i] an empty list;
        for i = 0 to n-1
            insert A[i] into list B[n*A[i]];
        for i = 0 to n-1
            sort list B[i] with insertion sort;
        concatenate the list B[0],B[1],...,B[n-1] together in order;