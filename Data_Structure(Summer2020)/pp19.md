# 07-图5 Saving James Bond - Hard Version (30point(s))

This time let us consider the situation in the movie "Live and Let Die" in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head... Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).

Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.

Input Specification:
Each input file contains one test case. Each case starts with a line containing two positive integers N (≤100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.

Output Specification:
For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.

Sample Input 1:
17 15
10 -21
10 21
-40 10
30 -50
20 40
35 10
0 -10
-25 22
40 -40
-30 30
-10 22
0 11
25 21
25 10
10 10
10 35
-30 10
Sample Output 1:
4
0 11
10 21
10 35
Sample Input 2:
4 13
-12 12
12 12
-12 -12
12 -12
Sample Output 2:
0

## my sol 1     20/7/20     80 min

状态很不好...本地都不对...不想写了，明天再搞

``` C++
#include <iostream>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

#define INF 1e308

struct Node{
    int x, y;
    int id;
    // double dist = INF;
    int dist = INT_MAX;     // 距离是节点的数量
    vector<Node*> parent = {};
    Node() = default;
    Node(int id, int x, int y): id(id), x(x), y(y) {}
};

bool visited[110];
vector<Node*> nodes, pq, dsts;
vector<vector<Node*>> ans;
int n, d;

double distance(Node* a1, Node* a2) {
    if (a1 == a2) return INF;
    return sqrt((double) (a1->x - a2->x) * (a1->x - a2->x) + (double) (a1->y - a2->y) * (a1->y - a2->y));
}

void dfs(Node* root, vector<Node*>& path) {
    if (root->parent[0] == root) {
        ans.push_back(path);
    }
    path.push_back(root);
    for (auto node : root->parent) {
        dfs(node, path);
        path.pop_back();
    }
}

int main() {
    fill(visited, visited + 110, false);
    scanf("%d %d", &n, &d);
    int x, y;
    Node* root = new Node(0, 0, 0);
    root->parent = {root};
    nodes.push_back(root);
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &x, &y);
        Node* newNode = new Node(i, x, y);
        nodes.push_back(newNode);
    }
    pq = nodes;

    auto cmp = [](Node* a1, Node* a2) {
        return a1->dist > a2->dist;
    };

    bool flag = false;
    Node* cur = nullptr;
    while (!pq.empty()) {
        make_heap(pq.begin(), pq.end(), cmp);
        pop_heap(pq.begin(), pq.end(), cmp), cur = pq.back(), pq.pop_back();
        visited[cur->id] = true;
        if (cur->parent.empty()) {
            flag = true;
            break;
        }
        if (abs(abs(cur->x) - 50) <= d || abs(abs(cur->y) - 50) <= d) {
            dsts.push_back(cur);
            continue;
        }
        for (int v = 1; v <= n; v++) {
            if (distance(cur, nodes[v]) <= (double) d && visited[v] == false) {
                if (nodes[v]->dist > cur->dist + 1) {
                    nodes[v]->dist = cur->dist + 1;
                    nodes[v]->parent = {cur};
                }
                if (nodes[v]->dist == cur->dist + 1) {
                    nodes[v]->parent.push_back(cur);
                }
            }
        }
    }

    if (flag) {
        printf("0");
        return 0;
    }
    
    sort(dsts.begin(), dsts.end(), [] (Node* a1, Node* a2) {return a1->dist < a2->dist;});
    int min_dist = dsts[0]->dist;
    for (auto dst : dsts) {
        if (dst->dist > min_dist) break;
        vector<Node*> temp;
        dfs(dst, temp);
    }

    double minD = INF; int idx;
    for (int i = 0, len = ans.size(); i < len; i++) {
        if (distance(ans[i][ans[i].size()-1], root) < minD) {
            minD = distance(ans[i][ans[i].size()-1], root);
            idx = i;
        }
    }

    printf("%d\n", min_dist);
    for (int i = 0; i < min_dist-1; i++) {
        auto node = ans[idx][ans[idx].size()-1-i];
        printf("%d %d\n", node->x, node->y);
    }
    return 0;
}
```

## my sol 2     20/7/21

好烦啊，没有一鼓作气之后就再而衰了，不想搞了，以后有时间有精力再来重写一遍吧

``` C++
#include <iostream>
#include <algorithm>
#include <vector>
#include <math.h>
using namespace std;

#define INF 1e308

struct Node{
    int x, y;
    int id;
    // double dist = INF;
    int dist = INT_MAX;     // 距离是节点的数量
    vector<Node*> parent = {};
    Node() = default;
    Node(int id, int x, int y): id(id), x(x), y(y) {}
};

bool visited[110];
vector<Node*> nodes, pq, dsts;
vector<vector<Node*>> ans;
int n, d;

double distance(Node* a1, Node* a2) {
    if (a1 == a2) return INF;
    return sqrt((double) (a1->x - a2->x) * (a1->x - a2->x) + (double) (a1->y - a2->y) * (a1->y - a2->y));
}

void dfs(Node* root, vector<Node*>& path) {
    if (root->parent[0] == root) {
        ans.push_back(path);
    }
    path.push_back(root);
    for (auto node : root->parent) {
        dfs(node, path);
        path.pop_back();
    }
}

int main() {
    fill(visited, visited + 110, false);
    scanf("%d %d", &n, &d);
    int x, y;
    Node* root = new Node(0, 0, 0);
    root->dist = 0;
    root->parent = {root};
    nodes.push_back(root);
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &x, &y);
        Node* newNode = new Node(i, x, y);
        nodes.push_back(newNode);
    }
    pq = nodes;

    auto cmp = [](Node* a1, Node* a2) {
        return a1->dist > a2->dist;
    };

    bool flag = false;
    Node* cur = nullptr;
    while (!pq.empty()) {
        make_heap(pq.begin(), pq.end(), cmp);
        pop_heap(pq.begin(), pq.end(), cmp), cur = pq.back(), pq.pop_back();
        visited[cur->id] = true;
        if (cur->parent.empty()) {
            flag = true;
            break;
        }
        if (abs(abs(cur->x) - 50) <= d || abs(abs(cur->y) - 50) <= d) {
            dsts.push_back(cur);
            continue;
        }
        if (cur == root) {
            for (int i = 0, len = pq.size(); i < len; i++) {
                if (distance(cur, pq[i]) - 7.5 <= (double) d && visited[pq[i]->id] == false) {
                    if (pq[i]->dist > cur->dist + 1) {
                        pq[i]->dist = cur->dist + 1;
                        pq[i]->parent = {cur};
                    } else if (pq[i]->dist == cur->dist + 1) {
                        pq[i]->parent.push_back(cur);
                    }
                }
            }
        } else {
            for (int i = 0, len = pq.size(); i < len; i++) {
                if (distance(cur, pq[i]) <= (double) d && visited[pq[i]->id] == false) {
                    if (pq[i]->dist > cur->dist + 1) {
                        pq[i]->dist = cur->dist + 1;
                        pq[i]->parent = {cur};
                    } else if (pq[i]->dist == cur->dist + 1) {
                        pq[i]->parent.push_back(cur);
                    }
                }
            }
        }
    }

    if (flag && dsts.empty()) {
        printf("0");
        return 0;
    }
    
    sort(dsts.begin(), dsts.end(), [] (Node* a1, Node* a2) {return a1->dist < a2->dist;});
    int min_dist = dsts[0]->dist;
    for (auto dst : dsts) {
        if (dst->dist > min_dist) break;
        vector<Node*> temp;
        dfs(dst, temp);
    }

    double minD = INF; int idx;
    for (int i = 0, len = ans.size(); i < len; i++) {
        if (distance(ans[i][ans[i].size()-1], root) < minD) {
            minD = distance(ans[i][ans[i].size()-1], root);
            idx = i;
        }
    }

    printf("%d\n", min_dist);
    for (int i = 0; i < min_dist-1; i++) {
        auto node = ans[idx][ans[idx].size()-1-i];
        printf("%d %d\n", node->x, node->y);
    }
    return 0;
}
```

## ref sol 1    20/7/21

``` C++
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#define Maxsize 1000
struct GraphNode{
	int topnum;
	int Maxdistance;
	int G[Maxsize][Maxsize];
};
struct Node{
	int v1;//起始点
	int v2; //末点
	int prenum;//前面一个顶点编号
//	int nownum;//自生编号
}zuobiao[Maxsize];
typedef struct GraphNode *GRAPH;
int Distance(int x,int y,GRAPH graphptr)
{
	return ( graphptr->Maxdistance * graphptr->Maxdistance >= (zuobiao[x].v1 - zuobiao[y].v1 ) * (zuobiao[x].v1 - zuobiao[y].v1 ) + (zuobiao[x].v2 - zuobiao[y].v2 ) * (zuobiao[x].v2 - zuobiao[y].v2 ));
}
void ComputeRightDis(GRAPH graphptr)
{
	int i = 0,j = 0;
	int dis = 0;
	for(i = 0;i <= graphptr->topnum - 1;i++)
	{
		for(j = 0;j <= graphptr->topnum - 1;j++)
		{
			dis = Distance( i , j ,graphptr);
			if( dis == 1 )//跳的距离判断是否在范围内
			{
				graphptr->G[ i ][ j ] = 1;
				graphptr->G[ j ][ i ] = 1;
			}
		}
	}
}
int Issafe(int v,GRAPH graphptr)
{
	return zuobiao[v].v1 <= -( 50 - graphptr->Maxdistance) || zuobiao[v].v1 >= 50 - graphptr->Maxdistance || zuobiao[v].v2 <= -( 50 - graphptr->Maxdistance) || zuobiao[v].v2  >=  50 - graphptr->Maxdistance;
}
int BFS(GRAPH graphptr)
{
	int i = -1,j = 0;
	while( ++i >= 0 && i <= graphptr->topnum - 1)
	{
		if(((graphptr->Maxdistance+7.5)*(graphptr->Maxdistance+7.5)>=(zuobiao[i].v1*zuobiao[i].v1 + zuobiao[i].v2*zuobiao[i].v2))&& (zuobiao[i].v1 *4* zuobiao[i].v1 + zuobiao[i].v2 *4* zuobiao[i].v2 > 225 )&& abs(zuobiao[i].v1) <=50 && abs(zuobiao[i].v2 <= 50))//第一批临近点)
		{
			int visited[Maxsize];
			int Queue[Maxsize];
			int front = -1;
			int rear = -1;
			Queue[++rear] = i;
			visited[i] = 1;
			zuobiao[i].prenum = -1;
			while(front != rear)
			{
				i = Queue[++front];//出队
				if( Issafe( i , graphptr ))//判断是否可以上岸
					return i;
				for(j = 0;j <= graphptr->topnum - 1;j++)
				{
					if(visited[j] == 0 && graphptr->G[i][j] == 1 && (zuobiao[j].v1 *4* zuobiao[j].v1 + zuobiao[j].v2 *4* zuobiao[j].v2 > 225 ))//与 v 相连的点
					{
						visited[j] = 1;
						Queue[++rear] = j;
						zuobiao[j].prenum = i;
					}
				}
			}
		}
	}
	return 0;
}
int main()
{
	int N = 0,D = 0,i = 0,j = 0,visited[Maxsize];
	scanf("%d %d",&N,&D);
        if( D+7.5 >= 50)
        {
		printf("1\n");
	}
	else
	{
		GRAPH graphptr = (GRAPH)malloc(sizeof(struct GraphNode));
		graphptr->topnum = N;
		graphptr->Maxdistance = D;
		for(i = 0;i <= graphptr->topnum - 1;i++)
		{
			scanf("%d %d",&zuobiao[i].v1,&zuobiao[i].v2);
		}
		ComputeRightDis(graphptr);//计算满足要求的点的距离
		int answer = BFS( graphptr );
		if(answer == 0)
			printf("0\n");
		else
		{
			int stack[100], top = 0,pace = 1,v = answer;  //栈
			while (v != -1)
			{                     //回溯路径，依次压栈
				++pace;
				stack[top++] = v;
				v = zuobiao[v].prenum;
			}
			printf("%d\n", pace);//总次数
			while (top)
			{                   //依次弹出栈内元素
				v = stack[--top];
				printf("%d %d\n",zuobiao[v].v1,zuobiao[v].v2);
   			}
		}
	}
	return 0;
}
```
